import { defineComponent, computed, ref, toRef, h, Fragment, Teleport, nextTick } from "vue";
import { p as pick, k as kebabCase } from "../../../vendor-2b2dbafd.mjs";
import { a as renderSlotNode } from "../../utils/headless-cf5c266f.mjs";
import { u as useMouseNavigation, a as useKeyboardNavigation } from "./hooks/useDropdownNavigation-04034f2c.mjs";
import { u as useAnchorSelector } from "./hooks/useAnchorSelector-15d1a9a7.mjs";
import { u as useCursorAnchor } from "./hooks/useCursorAnchor-2713a35a.mjs";
import { u as useDropdown } from "./hooks/useDropdown-eb65d3ff.mjs";
import { w as warn } from "../../utils/console-33a7ea8d.mjs";
import { u as useFocusOutside } from "../../composables/useFocusOutside-a13ca1f7.mjs";
import { u as useTeleported } from "../../composables/useTeleported-c9f0a2cb.mjs";
import { a as usePlacementAliasesProps } from "../../composables/usePlacementAliases-c092b4d3.mjs";
import { c as createStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful-50e4a6b9.mjs";
import { u as useHTMLElementSelector } from "../../composables/useHTMLElementSelector-378861e4.mjs";
import { u as useBem } from "../../composables/useBem-33d80128.mjs";
import { u as useDebounceFn } from "../../composables/useDebounce-b095e529.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside-4e7f583c.mjs";
import { u as useTranslation } from "../../composables/useTranslation-5e716487.mjs";
import { u as useIsMounted } from "../../composables/useIsMounted-a63f9559.mjs";
import { u as useHTMLElement } from "../../composables/useHTMLElement-af551f75.mjs";
const _sfc_main = defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(Boolean, true),
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:toggleDropdown" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit }) {
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef: anchor } = useAnchorSelector(props);
    const cursorAnchor = computed(() => props.cursor ? useCursorAnchor(anchor, valueComputed).value : void 0);
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props.target));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      return body.value;
    });
    const teleportDisabled = computed(() => {
      return props.disabled;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onClick = (e) => {
      if (props.trigger !== "click" && kebabCase(props.trigger) !== "right-click" || props.disabled) {
        return;
      }
      if (valueComputed.value) {
        emitAndClose("anchor-click", props.closeOnAnchorClick, e);
      } else {
        if (props.trigger !== "click") {
          return;
        }
        valueComputed.value = true;
        emit("anchor-click", e);
      }
    };
    const onContextmenu = (e) => {
      if (kebabCase(props.trigger) !== "right-click" || props.disabled) {
        return;
      }
      e.preventDefault();
      if (valueComputed.value) {
        emitAndClose("anchor-right-click", props.closeOnAnchorClick, e);
        if (props.cursor) {
          nextTick(() => {
            valueComputed.value = true;
          });
        }
      } else {
        valueComputed.value = true;
        emit("anchor-right-click", e);
      }
    };
    const onDblclick = () => {
      return void 0;
    };
    const onMouseenter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseleave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    useMouseNavigation(anchor, {
      click: onClick,
      contextmenu: onContextmenu,
      dblclick: onDblclick,
      mouseenter: onMouseenter,
      mouseleave: onMouseleave
    });
    if (props.keyboardNavigation) {
      useKeyboardNavigation(anchor, valueComputed);
    }
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    const floatingListeners = {
      onMouseover: () => props.isContentHoverable && onMouseenter(),
      onMouseout: () => onMouseleave(),
      onClick: () => emitAndClose("content-click", props.closeOnContentClick)
    };
    useClickOutside([anchor, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      return cursorAnchor.value || anchor.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchor,
      anchorClass,
      floating,
      floatingStyles,
      teleportDisabled,
      showFloating,
      teleportTarget,
      floatingListeners,
      isMounted,
      valueComputed,
      hide,
      show
    };
  },
  render() {
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, {}, {
      ref: "floating",
      class: "va-dropdown__content-wrapper",
      style: this.floatingStyles,
      ...this.teleportedAttrs,
      ...this.floatingListeners
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, {}, {
      ref: "anchor",
      role: "button",
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": !!this.showFloating,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.teleportDisabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});
export {
  _sfc_main as _
};

import '../../../VaDropdown.css';
//# sourceMappingURL=VaDropdown.vue_vue_type_script_lang-bd54f7a4.mjs.map
