import { defineComponent, shallowRef, computed, useCssVars } from "vue";
import { g as generateUniqueId } from "../../utils/uuid.js";
import { V as VaMessageListWrapper } from "../va-input/components/VaMessageListWrapper.js";
import { u as useSelectableEmits, a as useSelectableProps, b as useSelectable } from "../../composables/useSelectable.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { u as useColors } from "../../composables/useColors.js";
const __default__ = defineComponent({
  name: "VaRadio",
  components: { VaMessageListWrapper },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value
    });
    const selectOption = (option, event) => {
      var _a;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a = event == null ? void 0 : event.target) == null ? void 0 : _a.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const computedName = computed(() => props.name || generateUniqueId());
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0,
        "aria-disabled": disabled,
        "aria-readOnly": props.readonly,
        ...validationAriaAttributes.value
      };
    };
    return {
      getDisabled,
      isChecked,
      computedOptions,
      radioClass,
      labelStyle,
      inputStyle,
      computedError,
      computedErrorMessages,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      selectOption,
      onFocus,
      onBlur,
      inputAttributesComputed,
      computedName,
      roleComputed: computed(() => {
        var _a;
        return ((_a = props.options) == null ? void 0 : _a.length) > 0 ? "radiogroup" : "";
      }),
      getText,
      getValue
    };
  }
});
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "1a6cfe3a": _ctx.labelStyle.color,
    "46af97b9": _ctx.iconComputedStyles.borderColor,
    "27fd67c0": _ctx.iconDotComputedStyles.borderColor,
    "39edc904": _ctx.iconDotComputedStyles.backgroundColor,
    "caaf72f6": _ctx.iconBackgroundComputedStyles.backgroundColor
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
export {
  __default__ as _
};
//# sourceMappingURL=VaRadio.vue_vue_type_script_lang.js.map
